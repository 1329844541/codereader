<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>从0到1起步-跟我进入堆外内存的奇妙世界</title>

	<link rel="shortcut icon" href="/styles/images/favicon.jpg">
	<link rel="icon" href="/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="/lang/java/%E4%BB%8E0%E5%88%B01%E8%B5%B7%E6%AD%A5-%E8%B7%9F%E6%88%91%E8%BF%9B%E5%85%A5%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/">
	<link rel="alternate" type="application/rss+xml" title="源码分析" href="/feed.xml">
	
	<meta name="description" content="源码分析的博客">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
               
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>


  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://ymgd.github.io/codereader/" class="navbar-brand">
        <img src="/styles/images/logo.jpg">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/">时间流</a>
        </li>
        <li>
          <a href="/categories/">按项目分</a>
        </li>
        <li>
          <a href="/tag">按语言分</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/ymgd/codereader">Github</a></li>
            <li><a href="/feed.xml">RSS订阅</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>

    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>从0到1起步-跟我进入堆外内存的奇妙世界</h1>
		    <p>Post on Oct 17, 2016 by <a href="/about">ymgd</a></p>
		-->
		    <h3>I am reading codes</h3>
    
  </div>
</div>

    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#Java-ref">Java</a>	/
    	<a href="/tag/#-ref"></a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2016">2016</a>
          <ul class="nav">
            <li><a href="#month_2016_November">November</a></li>
      

      
            
          
              <li><a href="#month_2016_October">October</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">从0到1起步-跟我进入堆外内存的奇妙世界</h1>
              <!--
                <p class="post-meta">Oct 17, 2016</p>
              -->
              
                <div class="meta">Posted on <span class="postdate">Oct 17, 2016</span> By <a target="_blank" href="https://github.com/ymgd">ymgd</a></div>
              
              <br />
            </header>
            <article class="post-content">
              <p>堆外内存一直是Java业务开发人员难以企及的隐藏领域，究竟他是干什么的，以及如何更好的使用呢？那就请跟着我进入这个世界吧。</p>

<h2 id="section">一、什么是堆外内存</h2>

<p>堆外内存一直是Java业务开发人员难以企及的隐藏领域，究竟他是干什么的，以及如何更好的使用呢？那就请跟着我进入这个世界吧。</p>

<h3 id="on-heap-memory">1、堆内内存（on-heap memory）回顾</h3>

<p>堆外内存和堆内内存是相对的二个概念，其中堆内内存是我们平常工作中接触比较多的，我们在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值，理解jvm的堆还需要知道下面这个公式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>堆内内存 = 新生代+老年代+持久代
</code></pre>
</div>

<p>如下面的图所示：</p>

<p><img src="/lang/java/resources/offheap/heap.png" alt="" /></p>

<p>在使用堆内内存（on-heap memory）的时候，完全遵守JVM虚拟机的内存管理机制，采用垃圾回收器（GC）统一进行内存管理，GC会在某些特定的时间点进行一次彻底回收，也就是Full GC，GC会对所有分配的堆内内存进行扫描，在这个过程中会对JAVA应用程序的性能造成一定影响，还可能会产生Stop The World。</p>

<p><strong>常见的垃圾回收算法主要有：</strong></p>

<ul>
  <li>引用计数器法（Reference Counting）</li>
  <li>标记清除法（Mark-Sweep）</li>
  <li>复制算法（Coping）</li>
  <li>标记压缩法（Mark-Compact）</li>
  <li>分代算法（Generational Collecting）</li>
  <li>分区算法（Region）</li>
</ul>

<p>注：在这里我们不对各个算法进行深入介绍，</p>

<h3 id="off-heap-memory">2、堆外内存（off-heap memory）介绍</h3>

<p>和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>

<p>作为JAVA开发者我们经常用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。</p>

<p>DirectByteBuffer类是在Java Heap外分配内存，对堆外内存的申请主要是通过成员变量unsafe来操作，下面介绍构造方法</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">DirectByteBuffer</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>                 
    <span class="kd">super</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cap</span><span class="o">,</span> <span class="n">cap</span><span class="o">);</span>
    <span class="c1">//内存是否按页分配对齐</span>
    <span class="kt">boolean</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">VM</span><span class="o">.</span><span class="na">isDirectMemoryPageAligned</span><span class="o">();</span>
    <span class="c1">//获取每页内存大小</span>
    <span class="kt">int</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">Bits</span><span class="o">.</span><span class="na">pageSize</span><span class="o">();</span>
    <span class="c1">//分配内存的大小，如果是按页对齐方式，需要再加一页内存的容量</span>
    <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">cap</span> <span class="o">+</span> <span class="o">(</span><span class="n">pa</span> <span class="o">?</span> <span class="n">ps</span> <span class="o">:</span> <span class="mi">0</span><span class="o">));</span>
    <span class="c1">//用Bits类保存总分配内存(按页分配)的大小和实际内存的大小</span>
    <span class="n">Bits</span><span class="o">.</span><span class="na">reserveMemory</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">cap</span><span class="o">);</span>

    <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
       <span class="c1">//在堆外内存的基地址，指定内存大小</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">OutOfMemoryError</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Bits</span><span class="o">.</span><span class="na">unreserveMemory</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">cap</span><span class="o">);</span>
        <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="na">setMemory</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mi">0</span><span class="o">);</span>
    <span class="c1">//计算堆外内存的基地址</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pa</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">base</span> <span class="o">%</span> <span class="n">ps</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Round up to page boundary</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ps</span> <span class="o">-</span> <span class="o">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">ps</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">cleaner</span> <span class="o">=</span> <span class="n">Cleaner</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="k">new</span> <span class="n">Deallocator</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="n">cap</span><span class="o">));</span>
    <span class="n">att</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>注：在Cleaner 内部中通过一个列表，维护了一个针对每一个 directBuffer 的一个回收堆外内存的 线程对象(Runnable)，回收操作是发生在 Cleaner 的 clean() 方法中。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Deallocator</span> <span class="kd">implements</span> <span class="n">Runnable</span>  <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Deallocator</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">long</span> <span class="n">size</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">address</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">address</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Paranoia</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">unsafe</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
        <span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">Bits</span><span class="o">.</span><span class="na">unreserveMemory</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">capacity</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="section-1">二、使用堆外内存的优点</h2>

<h3 id="section-2">1、减少了垃圾回收</h3>

<p>因为垃圾回收会暂停其他的工作。</p>

<h3 id="section-3">2、加快了复制的速度</h3>

<p>堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。</p>

<p>同样任何一个事物使用起来有优点就会有缺点，堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。</p>

<h2 id="directbytebuffer">三、使用DirectByteBuffer的注意事项</h2>

<p>java.nio.DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到java.nio.DirectByteBuffer对象里，这样就可以直接操作这些内存。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。</p>

<h2 id="directbytebuffer-1">四、DirectByteBuffer使用测试</h2>

<p>我们在写NIO程序经常使用ByteBuffer来读取或者写入数据，那么使用ByteBuffer.allocate(capability)还是使用ByteBuffer.allocteDirect(capability)来分配缓存了？第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢；第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相对较快。</p>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">stevex</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">nio</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectByteBufferTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
            <span class="c1">//分配128MB直接内存</span>
        <span class="n">ByteBuffer</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">128</span><span class="o">);</span>

        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ok"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>测试用例1：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Direct</span> <span class="n">buffer</span> <span class="n">memory</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">Bits</span><span class="o">.</span><span class="na">reserveMemory</span><span class="o">(</span><span class="n">Bits</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">658</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">DirectByteBuffer</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">DirectByteBuffer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">123</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">306</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">stevex</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">DirectByteBufferTest</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">DirectByteBufferTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">8</span><span class="o">)</span>
</code></pre>
</div>

<p>测试用例2：设置JVM参数-Xmx256m，运行正常，因为128M小于256M，属于范围内分配。</p>

<p>测试用例3：设置JVM参数-Xmx256m -XX:MaxDirectMemorySize=100M，运行异常，分配的直接内存128M超过限定的100M。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Direct</span> <span class="n">buffer</span> <span class="n">memory</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">Bits</span><span class="o">.</span><span class="na">reserveMemory</span><span class="o">(</span><span class="n">Bits</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">658</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">DirectByteBuffer</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">DirectByteBuffer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">123</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">306</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">stevex</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">DirectByteBufferTest</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">DirectByteBufferTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">8</span><span class="o">)</span>
</code></pre>
</div>

<p>测试用例4：设置JVM参数-Xmx768m，运行程序观察内存使用变化，会发现clean()后内存马上下降，说明使用clean()方法能有效及时回收直接缓存。
代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">stevex</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">nio</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">sun.nio.ch.DirectBuffer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectByteBufferTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
        <span class="c1">//分配512MB直接缓存</span>
        <span class="n">ByteBuffer</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">512</span><span class="o">);</span>

        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

        <span class="c1">//清除直接缓存</span>
        <span class="o">((</span><span class="n">DirectBuffer</span><span class="o">)</span><span class="n">bb</span><span class="o">).</span><span class="na">cleaner</span><span class="o">().</span><span class="na">clean</span><span class="o">();</span>

        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ok"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="systemgc">五、细说System.gc方法</h2>

<h3 id="jdksystemgc">1、JDK里的System.gc的实现</h3>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * Runs the garbage collector.
 * &lt;p&gt;
 * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual
 * Machine expend effort toward recycling unused objects in order to
 * make the memory they currently occupy available for quick reuse.
 * When control returns from the method call, the Java Virtual
 * Machine has made a best effort to reclaim space from all discarded
 * objects.
 * &lt;p&gt;
 * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the
 * call:
 * &lt;blockquote&gt;&lt;pre&gt;
 * Runtime.getRuntime().gc()
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @see     java.lang.Runtime#gc()
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">gc</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">gc</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>其实发现System.gc方法其实是调用的Runtime.getRuntime.gc()，我们再接着看。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
  运行垃圾收集器。
调用此方法表明，java虚拟机扩展
努力回收未使用的对象，以便内存可以快速复用，
当控制从方法调用返回的时候，虚拟机尽力回收被丢弃的对象
*/</span>
<span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">gc</span><span class="o">();</span>
</code></pre>
</div>

<p>这里看到gc方法是native的，在java层面只能到此结束了，代码只有这么多，要了解更多，可以看方法上面的注释，不过我们需要更深层次地来了解其实现，那还是准备好进入到jvm里去看看。</p>

<h3 id="systemgc-1">2、System.gc的作用有哪些</h3>

<p>说起堆外内存免不了要提及System.gc方法，下面就是使用了System.gc的作用是什么？</p>

<ul>
  <li>做一次full gc</li>
  <li>执行后会暂停整个进程。</li>
  <li>System.gc我们可以禁掉，使用-XX:+DisableExplicitGC，</li>
  <li>其实一般在cms gc下我们通过-XX:+ExplicitGCInvokesConcurrent也可以做稍微高效一点的gc，也就是并行gc。</li>
  <li>最常见的场景是RMI/NIO下的堆外内存分配等</li>
</ul>

<p>注：</p>

<p>如果我们使用了堆外内存，并且用了DisableExplicitGC设置为true，那么就是禁止使用System.gc，这样堆外内存将无从触发极有可能造成内存溢出错误，在这种情况下可以考虑使用ExplicitGCInvokesConcurrent参数。</p>

<p>说起Full gc我们最先想到的就是stop thd world，这里要先提到VMThread，在jvm里有这么一个线程不断轮询它的队列，这个队列里主要是存一些VM_operation的动作，比如最常见的就是内存分配失败要求做GC操作的请求等，在对gc这些操作执行的时候会先将其他业务线程都进入到安全点，也就是这些线程从此不再执行任何字节码指令，只有当出了安全点的时候才让他们继续执行原来的指令，因此这其实就是我们说的stop the world(STW)，整个进程相当于静止了。</p>

<h2 id="section-4">六、开源堆外缓存框架</h2>

<p>关于堆外缓存的开源实现。查询了一些资料后了解到的主要有：</p>

<ul>
  <li>Ehcache 3.0：3.0基于其商业公司一个非开源的堆外组件的实现。</li>
  <li>Chronical Map：OpenHFT包括很多类库，使用这些类库很少产生垃圾，并且应用程序使用这些类库后也很少发生Minor GC。类库主要包括：Chronicle Map，Chronicle Queue等等。</li>
  <li>OHC：来源于Cassandra 3.0， Apache v2。</li>
  <li>Ignite: 一个规模宏大的内存计算框架，属于Apache项目。</li>
</ul>


            </article>
        </div>
      </div>
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            


  <div class="ds-thread" data-thread-key="/lang/java/%E4%BB%8E0%E5%88%B01%E8%B5%B7%E6%AD%A5-%E8%B7%9F%E6%88%91%E8%BF%9B%E5%85%A5%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/" data-title="从0到1起步-跟我进入堆外内存的奇妙世界" data-url="https://ymgd.github.io/codereader/lang/java/%E4%BB%8E0%E5%88%B01%E8%B5%B7%E6%AD%A5-%E8%B7%9F%E6%88%91%E8%BF%9B%E5%85%A5%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/"></div>

<script type="text/javascript">
var duoshuoQuery = {short_name:"luoyan35714"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


 
          </div>
        </article>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2018 <a href=""><code>ymgd</code></a>.</p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme from <a href="http://lesscss.cn/">Less</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/application.js"></script>
<script src="/styles/js/lessismore.js"></script>

  </body>
</html>
